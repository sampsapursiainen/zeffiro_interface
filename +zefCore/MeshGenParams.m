classdef MeshGenParams
%
% MeshGenParams
%
% This class defines the input parameters to the finite element mesh generation
% routine, that are only utilized inside of it and are not stored into the
% central data structure zef. The user of the mesh generator should construct
% an object of this class, and then pass it to the mesh generation routine as
% the "params" keyword argument.
%

    properties
        %
        % This integer vector defines which compartments will have their
        % surfaces refined during the optional adaptive surface refinement pass
        % of mesh generation. The numbers are the ordinals of the compartments
        % as given in the segmentation import script file
        % import_segmentation.zef, which is used in importing a segmentation
        % generated by FreeSurfer or other similar software. Note that the
        % import script contains lines for both left and right hemispheres, so
        % the number of lines in the file should be divided by 2 to get the
        % actual total number of compartments. The special value of -1 in this
        % vector includes all active compartments in the the set of
        % compartments being refined.
        %
        adaptive_refinement_compartments (1,:) double { mustBeInteger } = -1
        %
        % The number of k nearest tetrahedra from a surface being refined. If
        % this is n, then tetrahedra that are n tetrahdra away from a surface
        % will be included into the refinement.
        %
        adaptive_refinement_k_param (1,1) double { mustBePositive, mustBeInteger } = 5
        %
        % The amount of times each compartment will be refined. If size is
        % (1,1), then all compartments will be refined the same number of
        % times. If this is a vector, then the integer at index i will
        % determine how many times the ith department in the list of
        % departments to be refined will be refined.
        %
        adaptive_refinement_number (1,:) double { mustBeInteger } = 1
        %
        % Determines whether adaptive refinement will be applied during mesh
        % generation.
        %
        adaptive_refinement_on (1,1) logical = false
        %
        % The threshold value which determines when adaptive refinement should
        % stop. This corresponds to the size of the median tetrahedron in the
        % refined tetrahedra, which based on the code seems to be the distance
        % from one vertex to the opposing face.
        %
        adaptive_refinement_thresh_val (1,1) double { mustBePositive } = 2
        %
        % Determines whether the assisting box that was used to construct an
        % initial mesh will be included in post-processing such as smoothing.
        %
        exclude_box (1,1) logical = true
        %
        % A mesh generated by Zeffiro might initially not align with the
        % imported segmentation, which is corrected by inflation or moving of
        % tetrahedral nodes towards segmentation boundaries. This parameter
        % determines how aggressively tetrahedral nodes slide towards a
        % segmented tissue boundary during mesh inflation, which occurs after
        % labeling. This must be between 0 and 1.
        %
        fem_mesh_inflation_strength (1,1) double { mustBeNonnegative } = 0.05
        %
        % Determines whether the surface nodes of a mesh (compartment) are
        % re-determined during each mesh smoothing step.
        %
        fix_outer_surface (1,1) logical = true
        %
        % This is either 1 or 2 and sets how the initial mesh is constructed.
        % If set to 1, each cube in the initial lattice is split into 5
        % tetrahedra with an alternating pattern of faces and edges, and 2
        % results in 6 tetrahedra with a non-alternating pattern.
        %
        initial_mesh_mode (1,1) double { mustBeMember (initial_mesh_mode, [1, 2]) } = 1
        %
        % TODO
        %
        mesh_labeling_approach (1,1) double { mustBeMember (mesh_labeling_approach, [1, 2]) } = 1
        %
        % TODO
        %
        mesh_optimization_parameter (1,1) double { mustBePositive } = 1e-5
        %
        % TODO
        %
        mesh_optimization_repetitions (1,1) double { mustBeNonnegative, mustBeInteger } = 10
        %
        % TODO
        %
        mesh_relabeling (1,1) logical = true
        %
        % The resolution of the initial hexahedral mesh in millimeters.
        %
        mesh_resolution (1,1) double { mustBePositive } = 4.5
        %
        % Toggles whether smoothing will be applied to the mesh.
        %
        mesh_smoothing_on (1,1) logical = true;
        %
        % The number of times a mesh will be smoothed.
        %
        mesh_smoothing_repetitions (1,1) double { mustBeNonnegative, mustBeInteger } = 1
        %
        % TODO
        %
        meshing_threshold (1,1) double { mustBePositive } = 0.25
        %
        % The length of the largest edge of a hexa- or tetrahedron in the
        % discretized perfectly matched layer (PML) box, which surrounds a
        % given finite element model.
        %
        pml_max_size (1,1) double { mustBePositive } = 2
        %
        % Determines whether the measure zef.pml_max_size is given relative to
        % the initial mesh size (1), or absolutely in mm (2).
        %
        pml_max_size_unit (1,1) double { mustBeMember ( pml_max_size_unit, [1, 2] ) } = 1
        %
        % This is half a side length of a cube in an initial hexahedral mesh,
        % before it has been split into tetrahedra.
        %
        pml_outer_radius (1,1) double { mustBePositive } = 1.1
        %
        % Describes whether zef.pml_outer_radius is relative to the initial
        % mesh size (1), or absolutely in mm (2).
        %
        pml_outer_radius_unit (1,1) double { mustBeMember ( pml_outer_radius_unit, [1, 2] ) } = 1
        %
        % TODO
        %
        reduce_labeling_outliers (1,1) logical = true
        %
        % Whether non-adaptive refinement will be performed on the mesh.
        %
        refinement_on (1,1) logical = true;
        %
        % This integer vector defines which compartments will have their
        % surfaces refined during the 1st optional surface refinement pass of
        % mesh generation. The numbers are the ordinals of the compartments as
        % given in the segmentation import script file import_segmentation.zef,
        % which is used in importing a segmentation generated by FreeSurfer or
        % other similar software. Note that the import script contains lines
        % for both left and right hemispheres, so the number of lines in the
        % file should be divided by 2 to get the actual total number of
        % compartments. The special value of -1 in this vector includes all
        % active compartments in the the set of compartments being refined.
        %
        refinement_surface_compartments (1,:) double { mustBeInteger } = [10 -1 1 18 17]
        %
        % This integer vector defines which compartments will have their
        % surfaces refined during the 2nd optional surface refinement pass of
        % mesh generation. The numbers are the ordinals of the compartments as
        % given in the segmentation import script file import_segmentation.zef,
        % which is used in importing a segmentation generated by FreeSurfer or
        % other similar software. Note that the import script contains lines
        % for both left and right hemispheres, so the number of lines in the
        % file should be divided by 2 to get the actual total number of
        % compartments. The special value of -1 in this vector includes all
        % active compartments in the the set of compartments being refined.
        %
        refinement_surface_compartments_2 (1,:) double { mustBeInteger } = -1
        %
        % The numbers of times each compartment selected for refinement are
        % refined. If this is a scalar, all compartments are refined an equal
        % number of times.
        %
        refinement_surface_number (1,:) double { mustBeInteger } = 1
        %
        % The numbers of times each compartment selected for refinement are
        % refined during the post-processing step. If this is a scalar, all
        % compartments are refined an equal number of times.
        %
        refinement_surface_number_2 (1,:) double { mustBeInteger } = 1
        %
        % If this is set to true, refinement is performed on the selected
        % surfaces. If this is false, surface refinement is not performed.
        %
        refinement_surface_on (1,1) logical = true
        %
        % If this is set to true, refinement is performed on the selected
        % surfaces during the post-processing step. If this is false, surface
        % refinement is not performed.
        %
        refinement_surface_on_2 (1,1) logical = false
        %
        % This integer vector defines which compartments will have their
        % surfaces refined during the optional 1st volumetric refinement pass
        % of mesh generation. The numbers are the ordinals of the compartments
        % as given in the segmentation import script file
        % import_segmentation.zef, which is used in importing a segmentation
        % generated by FreeSurfer or other similar software. Note that the
        % import script contains lines for both left and right hemispheres, so
        % the number of lines in the file should be divided by 2 to get the
        % actual total number of compartments. The special value of -1 in this
        % vector includes all active compartments in the the set of
        % compartments being refined.
        %
        refinement_volume_compartments (1,:) double { mustBeInteger } = -1
        %
        % This integer vector defines which compartments will have their
        % surfaces refined during the optional 2nd volumetric refinement pass
        % of mesh generation. The numbers are the ordinals of the compartments
        % as given in the segmentation import script file
        % import_segmentation.zef, which is used in importing a segmentation
        % generated by FreeSurfer or other similar software. Note that the
        % import script contains lines for both left and right hemispheres, so
        % the number of lines in the file should be divided by 2 to get the
        % actual total number of compartments. The special value of -1 in this
        % vector includes all active compartments in the the set of
        % compartments being refined.
        %
        refinement_volume_compartments_2 (1,:) double { mustBeInteger } = -1
        %
        % The numbers of times each compartment selected for volumetric
        % refinement are refined. If this is a scalar, all compartments are
        % refined an equal number of times.
        %
        refinement_volume_number (1,:) double { mustBeInteger } = 1
        %
        % The numbers of times each compartment selected for volumetric
        % refinement are refined during the post-processing step. If this is a
        % scalar, all compartments are refined an equal number of times.
        %
        refinement_volume_number_2 (1,:) double { mustBeInteger } = 1
        %
        % This switch enables or disables volumetric refinement during the
        % first pass.
        %
        refinement_volume_on (1,1) logical = false
        %
        % This switch enables or disables volumetric refinement during the
        % post-processing pass.
        %
        refinement_volume_on_2 (1,1) logical = false
        %
        % TODO
        %
        smoothing_steps_ele (1,1) double { mustBePositive } = 0.2
        %
        % The number of times smoothing is applied to each compartment surface.
        % If this is a scalar, each surface is smoothed the same number of
        % times.
        %
        smoothing_steps_surf (1,1) double { mustBePositive } = 0.10
        %
        % The number of times smoothing is applied to each compartment volume.
        % If this is a scalar, each compartment volume is smoothed the same
        % number of times.
        %
        smoothing_steps_vol (1,1) double { mustBePositive } = 0.90
        %
        % This switch determines whether mesh inflation is applied or not.
        %
        use_fem_mesh_inflation (1,1) logical = true
        %
    end % properties

    methods

        function self = MeshGenParams ( kwargs )
        %
        % self = MeshGenParams ( kwargs )
        %
        % A constructor of this class. The kwargs contain the properties of
        % this class, that one wishes to set. The ones that are omitted will
        % use the default values.
        %

            arguments
                kwargs.adaptive_refinement_compartments = -1
                kwargs.adaptive_refinement_k_param = 5
                kwargs.adaptive_refinement_number = 1
                kwargs.adaptive_refinement_on = false
                kwargs.adaptive_refinement_thresh_val = 2
                kwargs.exclude_box = true
                kwargs.fem_mesh_inflation_strength = 0.05
                kwargs.fix_outer_surface = true
                kwargs.initial_mesh_mode = 1
                kwargs.mesh_labeling_approach = 1
                kwargs.mesh_optimization_parameter = 1e-5
                kwargs.mesh_optimization_repetitions = 10
                kwargs.mesh_relabeling = true
                kwargs.mesh_resolution = 4.5
                kwargs.mesh_smoothing_on = true;
                kwargs.mesh_smoothing_repetitions = 1
                kwargs.meshing_threshold = 0.25
                kwargs.pml_max_size = 2
                kwargs.pml_max_size_unit = 1
                kwargs.pml_outer_radius = 1.1
                kwargs.pml_outer_radius_unit = 1
                kwargs.reduce_labeling_outliers = true
                kwargs.refinement_on = true;
                kwargs.refinement_surface_compartments = [10 -1 1 18 17]
                kwargs.refinement_surface_compartments_2 = -1
                kwargs.refinement_surface_number = 1
                kwargs.refinement_surface_number_2 = 1
                kwargs.refinement_surface_on = true
                kwargs.refinement_surface_on_2 = false
                kwargs.refinement_volume_compartments = -1
                kwargs.refinement_volume_compartments_2 = -1
                kwargs.refinement_volume_number = 1
                kwargs.refinement_volume_number_2 = 1
                kwargs.refinement_volume_on = false
                kwargs.refinement_volume_on_2 = false
                kwargs.smoothing_steps_ele = 0.2
                kwargs.smoothing_steps_surf = 0.10
                kwargs.smoothing_steps_vol = 0.90
                kwargs.use_fem_mesh_inflation = true
            end

            fns = string ( fieldnames ( kwargs ) ) ;

            for fnI = 1 : numel ( fns )

                self.(fns(fnI)) = kwargs.(fns(fnI)) ;

            end % for

        end % function

    end % methods

end % classdef
